import os
import math
import PIL
import random
import timeit
from PIL import Image


def nearest_power_of_2(x):
    return 2 ** math.ceil(math.log(x, 2))

def getImageSize(taille_octets):
    return math.ceil(math.sqrt(taille_octets))

def createImageBW(octets, image_size):
    image = PIL.Image.new(mode="L", size=(image_size, image_size))
    image.putdata(octets)  # Set entire image data at once
    return image


#using the PIL functions version
def createImageRGB2(octets):
    size = len(octets)
    pixel_count = size // 3
    image_size = int(pixel_count ** 0.5)

    # Create image directly from bytes
    image = PIL.Image.frombytes(mode="RGB", size=(image_size, image_size), data=bytes(octets))

    return image

#handmade version
def createImageRGB(octets):
    size = len(octets)
    image_size = getImageSize(size//3)
    image = PIL.Image.new(mode="RGB", size=(image_size, image_size))

    n = 0
    for i in range(size//3):
        x = i % image_size
        y = i // image_size
        
        image.putpixel((x,y), (octets[n],octets[n+1],octets[n+2])) 
        n += 3

    return image

def randomCut(data, required_length, cut_coeff=0.2, cut_size = 10):
    print('bondou1')
    if len(data) >= required_length / (cut_coeff*2):
        return data[required_length*0.5:] + data[:len(data) - required_length*0.5] #if the file is too long will only keep the beginning and the end
    
    excedent = required_length - len(data)
    mid_data = data[int(len(data)*cut_coeff):int(len(data)*(1-cut_coeff))]

    for _ in range(excedent//cut_size):
        index = random.randint(0, len(mid_data) - cut_size)
        for j in range(cut_size):
            del mid_data[index + j]

    cut_data = data[:int(len(data)*cut_coeff)] + mid_data + data[int(len(data)*(1-cut_coeff)):]
    

    if len(cut_data) < required_length:
        padding_length = required_length - len(data)
        cut_data += bytes(random.randint(0, 255) for _ in range(padding_length))
    elif len(cut_data) > required_length:
        cut_data = data[:required_length]

    print('auvoir1')
    return cut_data
    

def prepare_image(path, type):
    with open(path, 'rb') as fichier:
        data = fichier.read()
    median_size = 6000000
    size = nearest_power_of_2(math.ceil(math.sqrt(median_size)))
    required_length = size * size

    

    if len(data) < required_length:
        padding_length = required_length - len(data)
        data += bytes(random.randint(0, 255) for _ in range(padding_length))
    elif len(data) > required_length:
        data = randomCut(data, required_length)

    if type == 'BW':
        return createImageBW(data, size)
    elif type == 'RGB':
        return createImageRGB(data)
    else:
        print("Available types are BW and RGB.")
    
def doInBatch():
    path = "/home/hugod/recherche/cti_code_folder/apks"
    type = 'RGB' #"RGB" for RGB image and "BW" for black and white image
    files = os.listdir(path)

    images_path = "/home/hugod/recherche/cti_code_folder/images"
    os.makedirs(images_path, exist_ok=True)

    if files:
        for file in files:
            full_path = os.path.join(path, file)
            image = prepare_image(full_path, type)
            image_filename = os.path.splitext(file)[0] + ".jpg"
            image_path = os.path.join(images_path, image_filename)
            print(f"Saving {image_filename} to {image_path}...")
            image.save(image_path)
    else:
        print("No files found in the directory.")


doInBatch()




