""" Main module for testing optimizers """
# Load libraries and pick the CUDA device if available
import json
import os
import argparse
import torch
import torch.nn as nn
import torch.nn.functional as F
#import torchvision
#import torchvision.transforms as transforms
from torch.utils.tensorboard import SummaryWriter
import torch.optim as optim
import matplotlib.pyplot as plt
#import numpy as np
import time
# Custom libraries
import torchvision.models as models
#from CustomOptimizer import *

from src.attack import FastGradientSignUntargeted
#from LinfPGDAttack import *
#import torchattacks

from helper import engine, data_setup

from loader import *
#from src.models import MODELS_MAP
from src.utils import *

import os
os.environ["CUDA_VISIBLE_DEVICES"] = "1"
use_cuda = torch.cuda.is_available()
device = torch.device("cpu")

TEST_FOLDER = '/home/hugodhugo/recherche/mini_dataset_images/test'
TRAIN_FOLDER = '/home/hugodhugo/recherche/mini_dataset_images/train'


# Trains the network

#   ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - Classic parse function, for now only takes the json and return the config_dict
#will later add other arguments for path and stuff
def parse_arguments():
    """Parse command-line arguments for the script."""
    parser = argparse.ArgumentParser(
        description="Convert APK files to images.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        '--config', default='config1.json', type=str, help='config file')
    parser.add_argument('--resume', '-r', action='store_true',
                        help='resume from checkpoint')
    parser.add_argument(
        "-d",
        "--dataset",
        default="_dataset",
        help="Root path of the APKs dataset. It is relative to your current working directory.",
    )
    args = parser.parse_args()

    dataset_path = args.dataset

    goodware_path = dataset_path + '/Goodware'
    malware_path = dataset_path + '/Malware'

    with open(args.config) as config_file:
        config = json.load(config_file)
    config_dict = {
    'dataset': config['dataset'],
    'batch_size': config['batch_size'],
    'optimizer': config['optimizer'],
    'lr': config['lr'],
    'momentum': config['momentum'],
    'epochs': config['epochs'],
    'tb_path_test': config['tb_path_test'],
    'tb_path_train': config['tb_path_train'],
    'weight_decay': config['weight_decay'],
    'random_seed': config['random_seed'],
    'n_eval_step': config['n_eval_step'],
    'log_folder': config['log_folder'],
    'epsilon': config['epsilon'],
    'k': config['k'],
    'alpha': config['alpha'],
    'frac': config['frac'],
    'goodware_path': goodware_path,
    'malware_path': malware_path
    }

    return config_dict

#../_images/test

#   ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - Function to load the dataset, returns train and test loaders
def loadDataset(config_dict):
    normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    transform = transforms.Compose([transforms.Resize((224, 224)), transforms.ToTensor(), normalize])
    trainloader, testloader, class_names = data_setup.create_dataloaders(TRAIN_FOLDER, TEST_FOLDER,transform,8)
    return trainloader, testloader, class_names
    
#H - This function will load the model, change the layers and put it on the device.
#Will return the pretrained model on the device, which is needed to create the adversarial attack.
#However he says "change the model to resnet18" and proceeds to put the resnet50... ?
def loadModelToDevice():
    # Change the model to ResNet-18
    
    model = models.resnet50(pretrained=True).to(device)

    # Change the fully connected layer structure to match ResNet-18's output (512 for ResNet-18 vs. 2048 for ResNet-50)
    model.fc = nn.Sequential(
                nn.Linear(2048, 500),
                nn.ReLU(inplace=True),  # Changed from Mish to ReLU; you can revert this if you have a specific reason to use Mish.
                nn.Linear(500, 2)).to(device)

    net = model.to(device)
    return net
    '''
    #DELETE MAP_LOCATION = ...
    model = torch.load("saved_models/model_test1.pth", map_location=torch.device('cpu'))
    #net = model.to(device)
    
    print(model["param_tensor"])
    return model
    '''

#    ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - This function we create the optimizer depending the one we chose in the json
#However i dont yet know the differences between those optimizers so i wouldnt know how to chose
def defineOptimizer(net):
    if config_dict['optimizer'] == 0:
        optimizer = optim.SGD(
        net.parameters(), lr=config_dict['lr'],
        momentum=config_dict['momentum'], weight_decay=config_dict['weight_decay'])
        return optimizer
    elif config_dict['optimizer'] == 1:
        optimizer = optim.Adagrad(
        net.parameters(), lr=config_dict['lr'], weight_decay=config_dict['weight_decay'])
        return optimizer
    elif config_dict['optimizer'] == 2:
        optimizer = optim.Adam(net.parameters(), lr=config_dict['lr'], amsgrad=0, weight_decay=config_dict['weight_decay'])
        return optimizer

#    ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - Not sure what it is used for 
def createPath(config_dict):
    # Writer path for display on TensorBoard
    if not os.path.exists(config_dict['tb_path_test']):
        os.makedirs(config_dict['tb_path_test'])
    if not os.path.exists(config_dict['tb_path_test']):
        os.makedirs(config_dict['tb_path_test'])

    if not os.path.exists(config_dict['tb_path_test']):
        os.makedirs(config_dict['tb_path_test'])
    #path_name = config_tb_path + \
    #    str(config_experiment_number) + "_" + str(optimizer)

#H - This function will create the adversarial attack with the pretrained model and then train and save the new model
def adversarial_attack(net, config_dict, criterion, optimizer, epochs):
    # Initialize weights
    net.apply(weights_init_uniform_rule)

    #load the model
    attack = FastGradientSignUntargeted(net, 
                                            config_dict['epsilon'], 
                                            config_dict['alpha'], 
                                            min_val=0, 
                                            max_val=1, 
                                            max_iters=config_dict['k'], 
                                            _type='linf')    
    
    writer = engine.create_writer(
            experiment_name="test",
            model_name="jsp_trop",
            extra=f"{epochs}_epochs_",
        )

    engine.train(model=net,
                 train_dataloader=trainloader,
                 test_dataloader=testloader,
                 optimizer=optimizer,
                 loss_fn=criterion,
                 epochs=epochs,
                 device=device,
                 writer=writer,
                 adv_training=True,
                 attack=attack)

    # Save the trained model
    torch.save(net, 'adv_trained_model_rgb_resnet_50.pth')




if __name__ == "__main__":
    config_dict = parse_arguments()

    torch.manual_seed(config_dict['random_seed'])
    if torch.cuda.is_available():
        torch.cuda.manual_seed(config_dict['random_seed'])

    image_prec = config_dict['frac']

    trainloader, testloader, class_names = loadDataset(config_dict)

    net = loadModelToDevice()

    criterion = nn.CrossEntropyLoss()

    optimizer = defineOptimizer(net)

    createPath(config_dict)

    logger = create_logger(config_dict['epsilon'],config_dict['log_folder'],'train','info')

    adversarial_attack(net, config_dict, criterion, optimizer, config_dict['epochs'])
