""" Main module for testing optimizers """
# Load libraries and pick the CUDA device if available
import json
import os
import argparse
import torch
import torch.nn as nn
import torch.nn.functional as F
#import torchvision
#import torchvision.transforms as transforms
from torch.utils.tensorboard import SummaryWriter
import torch.optim as optim
import matplotlib.pyplot as plt
#import numpy as np
import time
# Custom libraries
import torchvision.models as models
#from CustomOptimizer import *

from src.attack import FastGradientSignUntargeted
#from LinfPGDAttack import *
#import torchattacks

from helper import engine, data_setup

import torchvision.transforms as transforms
#from src.models import MODELS_MAP
from src.utils import *

import os
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


"""

DISCLAIMER : CE FICHIER EST TRES MOCHE C EST LE BAZAR MAIS IL SERA RANGE APRES

"""

TEST_FOLDER = '/home/hugodhugo/recherche/mini_dataset_images/test'
TRAIN_FOLDER = '/home/hugodhugo/recherche/mini_dataset_images/train'


# Trains the network

#   ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - Classic parse function, for now only takes the json and return the config_dict
#will later add other arguments for path and stuff
def parse_arguments():
    """Parse command-line arguments for the script."""
    parser = argparse.ArgumentParser(
        description="Convert APK files to images.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-c",
        '--config', default='config1.json', type=str, help='config file')
    parser.add_argument('--resume', '-r', action='store_true',
                        help='resume from checkpoint')
    parser.add_argument(
        "-d",
        "--dataset",
        default="_dataset",
        help="Root path of the APKs dataset. It is relative to your current working directory.",
    )
    parser.add_argument(
        "-o",
        "--output",
        default="adv_model",
        help="Name of the .pth file to be saved.",
    )
    parser.add_argument(
        "-w",
        "--weights",
        default='saved_models/resnet50_RGB_black_50_epochs_png.pth',
        help="Root path of the .pth file for the base weigths.",
    )
    parser.add_argument(
        "-a",
        "--attack",
        default=True,
        help="Add the option to test the same model without the attack for comparaison purpose.",
    )
    args = parser.parse_args()

    dataset_path = args.dataset
    output_path = args.output
    do_attack = args.attack 

    train_path = dataset_path + '/train'
    test_path = dataset_path + '/test'

    custom_weights = False
    custom_weights_path = None

    if args.weights:
        custom_weights = True
        custom_weights_path = args.weights


    with open(args.config) as config_file:
        config = json.load(config_file)
    config_dict = {
    'dataset': config['dataset'],
    'batch_size': config['batch_size'],
    'optimizer': config['optimizer'],
    'lr': config['lr'],
    'momentum': config['momentum'],
    'epochs': config['epochs'],
    'tb_path_test': config['tb_path_test'],
    'tb_path_train': config['tb_path_train'],
    'weight_decay': config['weight_decay'],
    'random_seed': config['random_seed'],
    'n_eval_step': config['n_eval_step'],
    'log_folder': config['log_folder'],
    'epsilon': config['epsilon'],
    'k': config['k'],
    'alpha': config['alpha'],
    'frac': config['frac'],
    'train_path': train_path,
    'test_path': test_path,
    'custom_weights': custom_weights,
    'custom_weights_path': custom_weights_path,
    'output_path': output_path,
    'do_attack': do_attack
    }

    return config_dict

#../_images/test

#   ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - Function to load the dataset, returns train and test loaders
def loadDataset(config_dict):
    normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    transform = transforms.Compose([transforms.Resize((224, 224)), transforms.ToTensor(), normalize])
    trainloader, testloader = data_setup.create_dataloaders(config_dict['train_path'], config_dict['test_path'],transform,8)
    return trainloader, testloader
    
#H - This function will load the model, change the layers and put it on the device.
#Will return the pretrained model on the device, which is needed to create the adversarial attack.
#However he says "change the model to resnet18" and proceeds to put the resnet50... ?
def loadModelToDevice(use_own_presets, custom_weights_path):
    # Change the model to ResNet-18
    if not use_own_presets:
        model = models.resnet50(pretrained=True).to(device)

        # Change the fully connected layer structure to match ResNet-18's output (512 for ResNet-18 vs. 2048 for ResNet-50)
        model.fc = nn.Sequential(
                    nn.Linear(2048, 500),
                    nn.ReLU(inplace=True),  # Changed from Mish to ReLU; you can revert this if you have a specific reason to use Mish.
                    nn.Linear(500, 2)).to(device)

        net = model.to(device)
        return net
    
    else:    
        #DELETE MAP_LOCATION = ...
        model = models.resnet50()

        # Load your own weights
        weights = torch.load(custom_weights_path, map_location=device)

        # Map the keys from the weights file to the model's state dictionary
        state_dict = model.state_dict()
        mapped_weights = {
            k: v for k, v in weights.items() if k in state_dict and v.shape == state_dict[k].shape
        }

        # Load the compatible keys into the model
        model.load_state_dict(mapped_weights, strict=False)

        model.fc = nn.Sequential(
                    nn.Linear(2048, 500),
                    nn.ReLU(inplace=True),  # Changed from Mish to ReLU; you can revert this if you have a specific reason to use Mish.
                    nn.Linear(500, 2)).to(device)

        net = model.to(device)
        return net

    

#    ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - This function we create the optimizer depending the one we chose in the json
#However i dont yet know the differences between those optimizers so i wouldnt know how to chose
def defineOptimizer(net):
    if config_dict['optimizer'] == 0:
        optimizer = optim.SGD(
        net.parameters(), lr=config_dict['lr'],
        momentum=config_dict['momentum'], weight_decay=config_dict['weight_decay'])
        return optimizer
    elif config_dict['optimizer'] == 1:
        optimizer = optim.Adagrad(
        net.parameters(), lr=config_dict['lr'], weight_decay=config_dict['weight_decay'])
        return optimizer
    elif config_dict['optimizer'] == 2:
        optimizer = optim.Adam(net.parameters(), lr=config_dict['lr'], amsgrad=0, weight_decay=config_dict['weight_decay'])
        return optimizer

#    ðŸ˜ŽðŸ‘ŒðŸ”¥
#H - Not sure what it is used for 
def createPath(config_dict):
    # Writer path for display on TensorBoard
    if not os.path.exists(config_dict['tb_path_test']):
        os.makedirs(config_dict['tb_path_test'])
    if not os.path.exists(config_dict['tb_path_test']):
        os.makedirs(config_dict['tb_path_test'])

    if not os.path.exists(config_dict['tb_path_test']):
        os.makedirs(config_dict['tb_path_test'])
    #path_name = config_tb_path + \
    #    str(config_experiment_number) + "_" + str(optimizer)

#H - This function will create the adversarial attack with the pretrained model and then train and save the new model
def adversarial_attack(net, config_dict, criterion, optimizer, epochs):
    # Initialize weights
    net.apply(weights_init_uniform_rule)

    #load the model
    attack = FastGradientSignUntargeted(net, 
                                            config_dict['epsilon'], 
                                            config_dict['alpha'], 
                                            min_val=0, 
                                            max_val=1, 
                                            max_iters=config_dict['k'], 
                                            _type='linf')    
    
    writer = engine.create_writer(
            experiment_name="test",
            model_name="jsp_trop",
            extra=f"{epochs}_epochs_",
        )

    engine.train(model=net,
                 train_dataloader=trainloader,
                 test_dataloader=testloader,
                 optimizer=optimizer,
                 loss_fn=criterion,
                 epochs=epochs,
                 device=device,
                 writer=writer,
                 adv_training=config_dict['do_attack'],
                 attack=attack)

    # Save the trained model
    torch.save(net, config_dict['output_path'])




if __name__ == "__main__":
    config_dict = parse_arguments()

    torch.manual_seed(config_dict['random_seed'])
    if torch.cuda.is_available():
        torch.cuda.manual_seed(config_dict['random_seed'])

    image_prec = config_dict['frac']

    trainloader, testloader = loadDataset(config_dict)

    net = loadModelToDevice(config_dict['custom_weights'], config_dict['custom_weights_path'])

    criterion = nn.CrossEntropyLoss()

    optimizer = defineOptimizer(net)

    createPath(config_dict)

    logger = create_logger(config_dict['epsilon'],config_dict['log_folder'],'train','info')

    adversarial_attack(net, config_dict, criterion, optimizer, config_dict['epochs'])
