import argparse
from pathlib import Path

import torch
from colorama import Fore, Style
from helper import data_setup, engine, models, utils
from torch import nn, optim

# Make the script interactive through the CLI
parser = argparse.ArgumentParser(
    description="Script to train and test a model.",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)

# Add the type of images the APK files should be converted to
parser.add_argument(
    "-t",
    "--type",
    choices=["RGB", "BW"],
    required=True,
    help="Type of images.",
)

# Add the padding type to use
parser.add_argument(
    "-p",
    "--padding_type",
    choices=["random", "black", "white"],
    required=True,
    help="Type of padding to used to create the images.",
)

args = parser.parse_args()

# Set the device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Setup directories
image_path = Path("_images")
train_dir = image_path / "train"
test_dir = image_path / "test"

# 1. Create epochs list
num_epochs = [10, 20, 30, 40, 50]

# 2. Create a list of models
models_choice = ["resnet18", "resnet50"]

# 3. Keep track of experiment numbers
experiment_number = 0

# 4. Loop through each number of epochs
for epochs in num_epochs:
    # 5. Loop through each model
    for model_name in models_choice:
        # 6. Create information print outs
        experiment_number += 1
        print(
            f"{Fore.GREEN}[INFO]{Style.RESET_ALL} Experiment number: {experiment_number}"
        )
        print(f"{Fore.GREEN}[INFO]{Style.RESET_ALL} Type of images: {args.type}")
        print(f"{Fore.GREEN}[INFO]{Style.RESET_ALL} Padding type: {args.padding_type}")
        print(f"{Fore.GREEN}[INFO]{Style.RESET_ALL} Model name: {model_name}")
        print(f"{Fore.GREEN}[INFO]{Style.RESET_ALL} Number of epochs: {epochs}")

        # 7. Create a new experiment name
        experiment_name = f"experiment_{experiment_number}"

        # 8. Create a new writer
        writer = engine.create_writer(
            experiment_name=experiment_name,
            model_name=model_name,
            extra=f"{epochs}_epochs",
        )
        torch.cuda.is_available()
        # 9. Create a new model
        match model_name:
            case "resnet18":
                model, weights = models.create_resnet18(device=device)
            case "resnet50":
                model, weights = models.create_resnet50(device=device)

        # 10. Create a new loss and optimizer for every model
        loss_fn = nn.CrossEntropyLoss()
        optimizer = optim.Adam(model.fc.parameters(), lr=0.001)

        # 11. Retrieve automatic transforms
        automatic_transforms = weights.transforms()

        # 12. Create a new train and test dataloader for every model
        train_dataloader, test_dataloader, class_names = data_setup.create_dataloaders(
            train_dir=train_dir,
            test_dir=test_dir,
            transform=automatic_transforms,
            batch_size=32,
        )

        print(
            f"{Fore.GREEN}[INFO]{Style.RESET_ALL} automatic_transforms: ",
            automatic_transforms,
        )
        print(
            f"{Fore.GREEN}[INFO]{Style.RESET_ALL} train_dataloader: ", train_dataloader
        )
        print(f"{Fore.GREEN}[INFO]{Style.RESET_ALL} test_dataloader: ", test_dataloader)
        print(
            f"{Fore.GREEN}[INFO]{Style.RESET_ALL} Number of classes: {len(class_names)}, class names: {class_names}"
        )
        # 13. Train the model
        engine.train(
            model=model,
            train_dataloader=train_dataloader,
            test_dataloader=test_dataloader,
            optimizer=optimizer,
            loss_fn=loss_fn,
            epochs=epochs,
            device=device,
            writer=writer,
        )

        # 14. Save the model
        save_filepath = (
            f"_models/{model_name}_{args.type}_{args.padding_type}_{epochs}_epochs.pth"
        )
        utils.save_model(
            model=model, target_dir="model_training", model_name=save_filepath
        )

        # 15. Close the writer
        writer.close()

        # 16. Print a line to separate the experiments
        print("-" * 100 + "\n")
