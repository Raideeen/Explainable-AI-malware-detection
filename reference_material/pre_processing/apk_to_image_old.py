import argparse
import glob
import math
import multiprocessing
import os
import random

import PIL
from PIL import Image
from tqdm import tqdm
from tqdm.contrib.concurrent import process_map

# Make the script interactive through the CLI
parser = argparse.ArgumentParser(
    description="Script to convert APK files to images.",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)

# Add the type of images the APK files should be converted to
parser.add_argument(
    "-t",
    "--type",
    choices=["RGB", "BW"],
    required=True,
    help="Type of images.",
)

# Add the padding type to use
parser.add_argument(
    "-p",
    "--padding_type",
    choices=["random", "black", "white"],
    required=True,
    help="Type of padding to use.",
)

# Add location to the APK files to convert (only the root folder)
parser.add_argument(
    "-d",
    "--dataset",
    nargs="?",
    default="_dataset",
    help="Provide the root path of the APKs dataset to convert. It is a path. It is a path relative to your current working directory.\nNote that it will look for any subdirectories in the root directory and gather all the files with '.apk' at the end.",
)

# Add location to the root location of the images to be saved at
parser.add_argument(
    "-i",
    "--images",
    nargs="?",
    default="_images",
    help="Provide the root path of the images to be saved at. It is a path relative to your current working directory.",
)

# Add choice on multicore or single core processing
parser.add_argument(
    "-m",
    "--multicore",
    choices=["yes", "no"],
    nargs="?",
    default="yes",
    help="Use multicore processing.",
)

args = parser.parse_args()


def nearest_power_of_2(x):
    return 2 ** math.ceil(math.log(x, 2))


def nearest_power_of_2_lower(x):
    return 2 ** (math.ceil(math.log(x, 2)) - 1)


def getImageSize(taille_octets):
    return math.ceil(math.sqrt(taille_octets))


def createImageBW(octets, image_size):
    image = PIL.Image.new(mode="L", size=(image_size, image_size))
    image.putdata(octets)  # Set entire image data at once
    return image


# handmade version
def createImageRGB(octets):
    size = len(octets)
    image_size = getImageSize(size // 3)
    image = PIL.Image.new(mode="RGB", size=(image_size, image_size))

    n = 0
    for i in range(size // 3):
        x = i % image_size
        y = i // image_size

        image.putpixel((x, y), (octets[n], octets[n + 1], octets[n + 2]))
        n += 3

    return image


# using the PIL functions version
def createImageRGB2(octets):
    size = len(octets)
    pixel_count = size // 3
    image_size = int(pixel_count**0.5)

    # Create image directly from bytes
    image = PIL.Image.frombytes(
        mode="RGB", size=(image_size, image_size), data=bytes(octets)
    )

    return image


def randomCut(data, required_length, cut_coeff=0.2, cut_size=10):
    if len(data) >= required_length / (cut_coeff * 2):
        return (
            data[: int(required_length * 0.5)]
            + data[int(len(data) - required_length * 0.5) :]
        )  # if the file is too long will only keep the beginning and the end

    excedent = required_length - len(data)
    mid_data = data[int(len(data) * cut_coeff) : int(len(data) * (1 - cut_coeff))]

    for _ in range(excedent // cut_size):
        index = random.randint(0, len(mid_data) - cut_size)
        for j in range(cut_size):
            del mid_data[index + j]

    cut_data = (
        data[: int(len(data) * cut_coeff)]
        + mid_data
        + data[int(len(data) * (1 - cut_coeff)) :]
    )

    if len(cut_data) < required_length:
        padding_length = required_length - len(data)
        cut_data += bytes(random.randint(0, 255) for _ in range(padding_length))
    elif len(cut_data) > required_length:
        cut_data = data[:required_length]

    return cut_data


# Median size considering the mean of all the medians of Goodware/Malware obf/non-obf (see pre_processing/median_size.ipynb)
MEDIAN_SIZE = 3524004
size = nearest_power_of_2_lower(math.ceil(math.sqrt(MEDIAN_SIZE)))  # Evaluate to 1024


def prepare_image(path, type, padding_type):
    with open(path, "rb") as fichier:
        data = fichier.read()
    required_length = size * size

    if len(data) < required_length:
        padding_length = required_length - len(data)

        match padding_type:
            case "random":
                # Random padding
                data += bytes(random.randint(0, 255) for _ in range(padding_length))
            case "black":
                # Padding with 0x00
                data += bytes(0 for _ in range(padding_length))
            case "white":
                # Padding with 0xFF
                data += bytes(255 for _ in range(padding_length))

    elif len(data) > required_length:
        data = data[:required_length]

    if type == "BW":
        return createImageBW(data, size)
    elif type == "RGB":
        return createImageRGB(data)
    else:
        print("Available types are BW and RGB.")


def process_apk(arguments):
    apk_path, type, padding_type = arguments
    images_path = args.images

    # Formatting string
    type = type.upper()
    padding_type = padding_type.upper()

    # Convert the APK file to an image
    image = prepare_image(apk_path, type, padding_type)

    # Get the subdirectory name of the APK file
    subdirectory = (
        os.path.basename(os.path.dirname(apk_path)) + f"_{type}_{padding_type}"
    )

    # Get the image name
    image_filename = os.path.splitext(os.path.basename(apk_path))[0] + ".jpg"

    # Create the subdirectory if it doesn't exist
    os.makedirs(os.path.join(images_path, subdirectory), exist_ok=True)

    # Save the image
    image_path = os.path.join(images_path, subdirectory, image_filename)
    image.save(image_path)
    tqdm.write(f"Saving {image_filename} to {image_path}...")


def doInBatch_single_core(type, padding_type):
    # Get the full paths of all .apk files in the _dataset directory and its
    # subdirectories
    apk_paths = glob.glob(f"{args.dataset}/*/*.apk", recursive=True)
    images_path = args.images

    for apk_path in apk_paths:
        # Convert the APK file to an image
        image = prepare_image(apk_path, type, padding_type)

        # Get the subdirectory name of the APK file
        subdirectory = os.path.basename(os.path.dirname(apk_path))

        # Get the image name
        image_filename = os.path.splitext(os.path.basename(apk_path))[0] + ".jpg"

        # Create the subdirectory if it doesn't exist
        os.makedirs(os.path.join(images_path, subdirectory), exist_ok=True)

        # Save the image
        image_path = os.path.join(images_path, subdirectory, image_filename)
        image.save(image_path)
        print(f"Saving {image_filename} to {image_path}...")
    print("Conversion of APK files to images complete.")


def doInBatch_multicore(type, padding_type):
    # Get the full paths of all .apk files in the _dataset directory and its
    # subdirectories
    apk_paths = glob.glob(f"{args.dataset}/*/*.apk", recursive=True)

    process_map(
        process_apk,
        [(apk_path, type, padding_type) for apk_path in apk_paths],
        max_workers=multiprocessing.cpu_count(),
    )

    print("Conversion of APK files to images complete.")


if __name__ == "__main__":
    # Create the images directory if it doesn't exist
    os.makedirs(args.images, exist_ok=True)

    if args.multicore == "yes":
        doInBatch_multicore(args.type, args.padding_type)
    else:
        doInBatch_single_core(args.type, args.padding_type)
