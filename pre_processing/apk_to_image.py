import os
import math
import random
import glob
import PIL
from PIL import Image
from multiprocessing import Pool


def nearest_power_of_2(x):
    return 2 ** math.ceil(math.log(x, 2))


def nearest_power_of_2_lower(x):
    return 2 ** (math.ceil(math.log(x, 2)) - 1)


def getImageSize(taille_octets):
    return math.ceil(math.sqrt(taille_octets))


def createImageBW(octets, image_size):
    image = PIL.Image.new(mode="L", size=(image_size, image_size))
    image.putdata(octets)  # Set entire image data at once
    return image


# handmade version
def createImageRGB(octets):
    size = len(octets)
    image_size = getImageSize(size // 3)
    image = PIL.Image.new(mode="RGB", size=(image_size, image_size))

    n = 0
    for i in range(size // 3):
        x = i % image_size
        y = i // image_size

        image.putpixel((x, y), (octets[n], octets[n + 1], octets[n + 2]))
        n += 3

    return image


# using the PIL functions version
def createImageRGB2(octets):
    size = len(octets)
    pixel_count = size // 3
    image_size = int(pixel_count**0.5)

    # Create image directly from bytes
    image = PIL.Image.frombytes(
        mode="RGB", size=(image_size, image_size), data=bytes(octets)
    )

    return image


def randomCut(data, required_length, cut_coeff=0.2, cut_size=10):
    if len(data) >= required_length / (cut_coeff * 2):
        return (
            data[: int(required_length * 0.5)] + data[int(len(data) - required_length * 0.5) :]
        )  # if the file is too long will only keep the beginning and the end

    excedent = required_length - len(data)
    mid_data = data[int(len(data) * cut_coeff) : int(len(data) * (1 - cut_coeff))]

    for _ in range(excedent // cut_size):
        index = random.randint(0, len(mid_data) - cut_size)
        for j in range(cut_size):
            del mid_data[index + j]

    cut_data = (
        data[: int(len(data) * cut_coeff)]
        + mid_data
        + data[int(len(data) * (1 - cut_coeff)) :]
    )

    if len(cut_data) < required_length:
        padding_length = required_length - len(data)
        cut_data += bytes(random.randint(0, 255) for _ in range(padding_length))
    elif len(cut_data) > required_length:
        cut_data = data[:required_length]

    print("auvoir1")
    return cut_data


# MEDIAN_SIZE = 6000000
MEDIAN_SIZE = 3524004
size = nearest_power_of_2_lower(math.ceil(math.sqrt(MEDIAN_SIZE)))


def prepare_image(path, type):
    with open(path, "rb") as fichier:
        data = fichier.read()
    required_length = size * size

    if len(data) < required_length:
        padding_length = required_length - len(data)
        # Random padding
        data += bytes(random.randint(0, 255) for _ in range(padding_length))

        # Padding with 0xFF
        # data += bytes(255 for _ in range(padding_length))
    elif len(data) > required_length:
        data = data[:required_length]

    if type == "BW":
        return createImageBW(data, size)
    elif type == "RGB":
        return createImageRGB(data)
    else:
        print("Available types are BW and RGB.")


def doInBatch(type):
    # Get the full paths of all .apk files in the _dataset directory and its
    # subdirectories
    apk_paths = glob.glob("_dataset/*/*.apk", recursive=True)
    images_path = "_images/"

    for apk_path in apk_paths:
        # Convert the APK file to an image
        image = prepare_image(apk_path, type)

        # Get the subdirectory name of the APK file
        subdirectory = os.path.basename(os.path.dirname(apk_path))

        # Get the image name
        image_filename = os.path.splitext(os.path.basename(apk_path))[0] + ".jpg"

        # Create the subdirectory if it doesn't exist
        os.makedirs(os.path.join(images_path, subdirectory), exist_ok=True)

        # Save the image
        image_path = os.path.join(images_path, subdirectory, image_filename)
        image.save(image_path)
        print(f"Saving {image_filename} to {image_path}...")
    print("Conversion of APK files to images complete.")


if __name__ == "__main__":
    doInBatch("RGB")
