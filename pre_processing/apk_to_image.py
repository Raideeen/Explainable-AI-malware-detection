import argparse
import glob
import math
import multiprocessing
import os
import random
from pathlib import Path

from androguard.core.bytecodes.apk import APK
from colorama import Fore, Style
from PIL import Image
from tqdm import tqdm
from tqdm.contrib.concurrent import process_map

# Constants
nearest_power_of_2_lower = lambda x: 2 ** (math.ceil(math.log(x, 2)) - 1)  # noqa: E731
MEDIAN_SIZE = 3524004
SIZE = nearest_power_of_2_lower(math.ceil(math.sqrt(MEDIAN_SIZE)))  # Evaluate to 1024

DEFAULT_IMAGE_SHAPE = "square"
DEFAULT_IMAGE_TYPE = "RGB"
DEFAULT_PADDING_TYPE = "random"
DEFAULT_EXTENSION_TYPE = "jpg"
DEFAULT_DATASET = "_dataset/30k_dataset"
DEFAULT_IMAGES = "_images"
DEFAULT_MULTICORE = "true"
DEFAULT_EXISTING = False

def parse_arguments():
    """Parse command-line arguments for the script."""
    parser = argparse.ArgumentParser(
        description="Convert APK files to images.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-s",
        "--image_shape",
        choices=["square", "vector"],  # square or 1D-vector
        default=DEFAULT_IMAGE_SHAPE,
        help="Shape of images to create.",
    )
    parser.add_argument(
        "-t",
        "--image_type",
        choices=["RGB", "BW"],
        required=True,
        default=DEFAULT_IMAGE_TYPE,
        help="Type of images to convert to.",
    )
    parser.add_argument(
        "-p",
        "--padding_type",
        choices=["random", "black", "white"],
        required=True,
        default=DEFAULT_PADDING_TYPE,
        help="Type of padding to use.",
    )
    parser.add_argument(
        "-ex", "--extension_type", choices=["jpg", "png"], required=True, default=DEFAULT_EXTENSION_TYPE
    )
    parser.add_argument(
        "-d",
        "--dataset",
        default=DEFAULT_DATASET,
        help="Root path of the APKs dataset. It is relative to your current working directory.",
    )
    parser.add_argument(
        "-i",
        "--images",
        default=DEFAULT_IMAGES,
        help="Root path where images will be saved. It is relative to your current working directory.",
    )
    parser.add_argument(
        "-m",
        "--multicore",
        choices=["true", "false"],
        default=DEFAULT_MULTICORE,
        help="Use multicore processing.",
    )
    parser.add_argument(
        "--time-based", action="store_true", default=DEFAULT_EXISTING, help="Use existing images directory. To be used if you have an already split dataset. For our case, it was in case we used a time-based split."
    )

    args = parser.parse_args()
    
    # Change the default dataset directory based on the --time-based flag
    if args.existing:
        args.dataset = "_dataset/71k_dataset"
    else:
        args.dataset = DEFAULT_DATASET
    
    return args


def get_dex_bytes(apk: APK) -> bytes:
    for f in apk.get_files():
        if f.endswith(".dex"):
            yield apk.get_file(f)


def create_image_bw(octets, image_size):
    """Create a black and white image from the given bytes."""
    image = Image.new(mode="L", size=(image_size, image_size))
    image.putdata(octets)  # Set entire image data at once
    return image


def create_image_rgb(octets):
    """Create an RGB image from the given bytes."""
    size = len(octets)
    image_size = math.ceil(math.sqrt(size // 3))
    image = Image.new(mode="RGB", size=(image_size, image_size))

    n = 0
    for i in range(size // 3):
        x, y = i % image_size, i // image_size
        image.putpixel((x, y), (octets[n], octets[n + 1], octets[n + 2]))
        n += 3

    return image


def create_image_vector(octets):
    """Creates a 1D grayscale image from the given bytes"""
    size = len(octets)
    image = Image.frombytes(mode="L", size=(1, size), data=octets)
    # image = image.resize((128*128, 1)) # downsize the image
    return image


def prepare_image(path, image_shape, image_type, padding_type):
    """Prepare image from APK file with specified shape, image_type and padding ."""
    required_length = SIZE * SIZE

    # OLD VERSION WITH ALL APK
    # with open(path, "rb") as file:
    #    data = file.read()

    # NEW VERSION WITH JUST DEX
    data = bytes()
    try:
        for s in get_dex_bytes(APK(path)):
            data += s
    except Exception:
        return None

    if len(data) < required_length:
        padding_length = required_length - len(data)  # change padding for 1D vector ?
        padding = {
            "random": bytes(random.randint(0, 255) for _ in range(padding_length)),
            "black": bytes(0 for _ in range(padding_length)),
            "white": bytes(255 for _ in range(padding_length)),
        }.get(padding_type, bytes())
        data += padding
    elif len(data) > required_length:
        data = data[:required_length]

    if image_shape == "square":
        if image_type == "BW":
            return create_image_bw(data, SIZE)
        elif image_type == "RGB":
            return create_image_rgb(data)
        else:
            raise ValueError(
                "Invalid image image_type. Available types are BW and RGB."
            )

    elif image_shape == "vector":
        return create_image_vector(data)

    else:
        raise ValueError("Invalid image_shape. Available shapes are square and vector")


def process_apk(args):
    """Process a single APK file to convert it to an image."""
    apk_path, image_shape, image_type, padding_type, extension_type, images_path, use_existing_split = args

    # Convert the APK file to an image
    image = prepare_image(apk_path, image_shape, image_type, padding_type)

    if image is None:
        tqdm.write(f"Skipping {apk_path}...")
        with open("pre_processing/problematic_apks.txt", "a") as file:
            file.write(f"{apk_path}\n")
        return

    # Get the subdirectory name of the APK file
    subdirectory = os.path.basename(
        os.path.dirname(apk_path)
        + f"_{image_shape}"
        + f"_{image_type.upper()}_{padding_type.upper()}"
    )
    
    if use_existing_split:
        # Get the parent directory name of the APK file
        parent_directory = Path(apk_path).parent.parent.name
        subdirectory = f"{parent_directory}/{subdirectory}" 
    
    # Get the image name
    image_filename = (
        os.path.splitext(os.path.basename(apk_path))[0] + f".{extension_type}"
    )

    # Create the subdirectory if it doesn't exist
    os.makedirs(os.path.join(images_path, subdirectory), exist_ok=True)

    # Save the image
    image_path = os.path.join(images_path, subdirectory, image_filename)
    image.save(image_path)
    tqdm.write(f"Saving {image_filename} to {image_path}...")


def do_in_batch(
    image_shape, image_type, padding_type, extension_type, images_path, multicore, use_existing_split
):
    """Process APK files in batch mode."""
    
    if use_existing_split:
        apk_paths = glob.glob(f"{args.dataset}/train/**/*.apk", recursive=True) + glob.glob(f"{args.dataset}/test/**/*.apk", recursive=True)
    else:
        apk_paths = glob.glob(f"{args.dataset}/**/*.apk", recursive=True)
        
    if multicore:
        max_workers = multiprocessing.cpu_count()
        process_args = [
            (
                apk_path,
                image_shape,
                image_type,
                padding_type,
                extension_type,
                images_path,
                use_existing_split,
            )
            for apk_path in apk_paths
        ]
        process_map(process_apk, process_args, max_workers=max_workers)
    else:
        for apk_path in apk_paths:
            process_apk(apk_path, image_shape, image_type, padding_type, images_path)

    print("Conversion of APK files to images complete.")


if __name__ == "__main__":
    args = parse_arguments()
    if not os.path.exists(args.dataset):
        print(
            f"{Fore.RED}[WARNING]{Style.RESET_ALL} The dataset folder is empty. Creating it now... Please populate it with APK files."
        )
        os.makedirs(args.dataset)
        exit()
    os.makedirs(args.images, exist_ok=True)
    do_in_batch(
        args.image_shape,
        args.image_type,
        args.padding_type,
        args.extension_type,
        args.images,
        args.multicore == "true",
        args.existing,
    )