import argparse
import glob
import math
import multiprocessing
import os
import random

from androguard.core.bytecodes.apk import APK
from colorama import Fore, Style
from PIL import Image
from tqdm import tqdm
from tqdm.contrib.concurrent import process_map

# Constants
nearest_power_of_2_lower = lambda x: 2 ** (math.ceil(math.log(x, 2)) - 1)  # noqa: E731
MEDIAN_SIZE = 3524004
SIZE = nearest_power_of_2_lower(math.ceil(math.sqrt(MEDIAN_SIZE)))  # Evaluate to 1024


def parse_arguments():
    """Parse command-line arguments for the script."""
    parser = argparse.ArgumentParser(
        description="Convert APK files to images.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-t",
        "--image_type",
        choices=["RGB", "BW"],
        required=True,
        help="Type of images to convert to.",
    )
    parser.add_argument(
        "-p",
        "--padding_type",
        choices=["random", "black", "white"],
        required=True,
        help="Type of padding to use.",
    )
    parser.add_argument(
        "-ex", "--extension_type", choices=["jpg", "png"], required=True
    )
    parser.add_argument(
        "-d",
        "--dataset",
        default="_dataset",
        help="Root path of the APKs dataset. It is relative to your current working directory.",
    )
    parser.add_argument(
        "-i",
        "--images",
        default="_images",
        help="Root path where images will be saved. It is relative to your current working directory.",
    )
    parser.add_argument(
        "-m",
        "--multicore",
        choices=["true", "false"],
        default="true",
        help="Use multicore processing.",
    )

    return parser.parse_args()


def get_dex_bytes(apk: APK) -> bytes:
    for f in apk.get_files():
        if f.endswith(".dex"):
            yield apk.get_file(f)


def create_image_bw(octets, image_size):
    """Create a black and white image from the given bytes."""
    image = Image.new(mode="L", size=(image_size, image_size))
    image.putdata(octets)  # Set entire image data at once
    return image


def create_image_rgb(octets):
    """Create an RGB image from the given bytes."""
    size = len(octets)
    image_size = math.ceil(math.sqrt(size // 3))
    image = Image.new(mode="RGB", size=(image_size, image_size))

    n = 0
    for i in range(size // 3):
        x, y = i % image_size, i // image_size
        image.putpixel((x, y), (octets[n], octets[n + 1], octets[n + 2]))
        n += 3

    return image


def prepare_image(path, image_type, padding_type):
    """Prepare image from APK file with specified padding and image_type."""
    required_length = SIZE * SIZE

    # OLD VERSION WITH ALL APK
    # with open(path, "rb") as file:
    #    data = file.read()

    # NEW VERSION WITH JUST DEX
    data = bytes()
    try:
        for s in get_dex_bytes(APK(path)):
            data += s
    except Exception:
        return None

    if len(data) < required_length:
        padding_length = required_length - len(data)
        padding = {
            "random": bytes(random.randint(0, 255) for _ in range(padding_length)),
            "black": bytes(0 for _ in range(padding_length)),
            "white": bytes(255 for _ in range(padding_length)),
        }.get(padding_type, bytes())
        data += padding
    elif len(data) > required_length:
        data = data[:required_length]

    if image_type == "BW":
        return create_image_bw(data, SIZE)
    elif image_type == "RGB":
        return create_image_rgb(data)
    else:
        raise ValueError("Invalid image image_type. Available types are BW and RGB.")


def process_apk(args):
    """Process a single APK file to convert it to an image."""
    apk_path, image_type, padding_type, extension_type, images_path = args

    # Convert the APK file to an image
    image = prepare_image(apk_path, image_type, padding_type)

    if image is None:
        tqdm.write(f"Skipping {apk_path}...")
        with open("pre_processing/problematic_apks.txt", "a") as file:
            file.write(f"{apk_path}\n")
        return

    # Get the subdirectory name of the APK file
    subdirectory = os.path.basename(
        os.path.dirname(apk_path) + f"_{image_type.upper()}_{padding_type.upper()}"
    )

    # Get the image name
    image_filename = (
        os.path.splitext(os.path.basename(apk_path))[0] + f".{extension_type}"
    )

    # Create the subdirectory if it doesn't exist
    os.makedirs(os.path.join(images_path, subdirectory), exist_ok=True)

    # Save the image
    image_path = os.path.join(images_path, subdirectory, image_filename)
    image.save(image_path)
    tqdm.write(f"Saving {image_filename} to {image_path}...")


def do_in_batch(image_type, padding_type, extension_type, images_path, multicore):
    """Process APK files in batch mode."""
    apk_paths = glob.glob(f"{args.dataset}/**/*.apk", recursive=True)

    if multicore:
        max_workers = multiprocessing.cpu_count()
        process_args = [
            (apk_path, image_type, padding_type, extension_type, images_path)
            for apk_path in apk_paths
        ]
        process_map(process_apk, process_args, max_workers=max_workers)
    else:
        for apk_path in apk_paths:
            process_apk(apk_path, image_type, padding_type, images_path)

    print("Conversion of APK files to images complete.")


if __name__ == "__main__":
    args = parse_arguments()
    if not os.path.exists(args.dataset):
        print(
            f"{Fore.RED}[WARNING]{Style.RESET_ALL} The dataset folder is empty. Creating it now... Please populate it with APK files."
        )
        os.makedirs(args.dataset)
    os.makedirs(args.images, exist_ok=True)
    do_in_batch(
        args.image_type,
        args.padding_type,
        args.extension_type,
        args.images,
        args.multicore == "true",
    )
